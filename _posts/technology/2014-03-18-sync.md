---
published: false
---

# 在node中实现阻塞

node.js中与生俱来的单线程编程、回调函数异步式风格让我们有时喜有时忧。先说单线程，很多人会费解于node.js的单线程如何能做到高并发？这个问题不是本文重点，点到为止。澄清一点，node.js的单线程仅仅指javascript引擎是单线程的，无论如何我们没有办法在javascript中实现多线程和阻塞（本文用到的方法同样不是通过V8引擎实现同步的）；但对于node.js的其他方面不代表不能多线程，例如IO。如果现在node.js遭受大量请求，而这些请求都是IO密集型的，那么此时node每接受一个请求，在遇到耗时较长的IO操作时，javascript线程并不会一直在此等待，而是交出控制，在回调堆栈里添加IO操作完成后要执行的操作（当回调层级过多，访问数量过大，大量的回调链可能会爆栈）。而在这段时间内，node.js又可以处理其他请求了。所以对于node.js而言，虽然javascript是单线程的，每次只能处理一个请求，但javascript处理一个请求的时间往往较短（对于IO密集型应用而言），只要可以异步处理，那么在处理的过程中，此次请求都会释放控制，使node.js能处理其他请求。这并发请求的同时，IO其实一直处于并发状态，减少处理请求的线程数，节约资源以增加IO的线程数，对于通常耗时很长的IO密集型请求来说，无疑能带来性能上的提升。

前面啰啰嗦嗦地一直在强调IO密集型，其实是在强调node.js的强项。相应的，它的短板就是CPU密集型的请求。道理很简单，javascript不会并发，只能一个请求完成后才能处理其他请求。一个请求处理的时间越长，其他请求等待的时间越长。同一时间只会有一个请求被处理，并发性能很低。

话说到这儿，我想申明一点：node.js不应该被阻塞；能异步处理的方法异步处理（如使用fs.readFile()，而非fs.syncReadFile()方法）。
